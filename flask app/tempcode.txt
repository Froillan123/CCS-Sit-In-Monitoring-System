/* Filter Container Styling */
.filter-container {
  margin-bottom: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  border-radius: 8px;
  margin-top: 2rem;
}

.filter-container label {
  font-weight: 500;
  color: var(--text-color);
}

#statusFilter {
  padding: 8px 12px;
  border-radius: 4px;
  border: 2px solid var(--first-color);
  background-color: white;
  color: var(--text-color);
  cursor: pointer;
}


/* Status Colors */
.status-pending {
  color: #ffc107; /* Yellow for Pending */
  font-weight: 500;
}

.status-approved {
  color: #14a636; /* Green for Approved */
  font-weight: 500;
}

/* Table Styling */
.reservations-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
  background-color: var(--background-color);
  color: var(--text-color);
}

.reservations-table th,
.reservations-table td {
  padding: 12px;
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.reservations-table th {
  background-color: var(--first-color);
  color: white;
  font-weight: 500;
}

.reservations-table tbody tr:hover {
  background-color: rgba(0, 0, 0, 0.05);
}

/* Button Styling */
.approve-btn {
  padding: 6px 12px;
  background-color: var(--first-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.approve-btn:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.approve-btn:hover:not(:disabled) {
  background-color: #9d2db0;
}

.cancel-btn {
  padding: 6px 12px;
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.cancel-btn:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.cancel-btn:hover:not(:disabled) {
  background-color: #c82333;
}

/* Responsive Design for Screens 1113px and Below */
@media (max-width: 1113px) {
  .reservations-table {
    display: block;
    width: 100%;
    overflow-x: auto; /* Allow horizontal scrolling if needed */
  }

  .reservations-table thead {
    display: none; /* Hide the table header on small screens */
  }

  .reservations-table tbody {
    display: block;
    width: 100%;
  }

  .reservations-table tr {
    display: block;
    margin-bottom: 15px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background-color);
  }

  .reservations-table td {
    display: block;
    text-align: right;
    padding: 10px;
    font-size: 14px;
    border-bottom: 1px solid var(--border-color);
  }

  .reservations-table td::before {
    content: attr(data-label); /* Use data-label attribute to show column headers */
    float: left;
    font-weight: 500;
    color: var(--first-color);
    text-transform: uppercase;
  }

  .reservations-table td:last-child {
    border-bottom: none; /* Remove border for the last cell in each row */
  }

  .approve-btn {
    width: 100%; /* Make the button full width on small screens */
    margin-top: 10px;
  }
}


my student javascript
const socketURL =
        window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:5000' // Local WebSocket URL
            : 'https://ccs-sit-in-monitoring-system.onrender.com'; // Render WebSocket URL

    const socket = io(socketURL, {
        transports: ['websocket'],
        upgrade: false,
        reconnection: true,
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
    });
    
  document.addEventListener('DOMContentLoaded', function () {
   // Section Toggling Logic
   const links = document.querySelectorAll('.sidebar-links a');
  const sections = document.querySelectorAll('.dashboard-section');

  // Function to show the selected section and hide others
  function showSection(sectionId) {
    sections.forEach(section => {
      section.style.display = section.id === sectionId ? 'block' : 'none';
    });
    localStorage.setItem('activeDashboardSection', sectionId); // Save the active section
  }

  // Function to set the active link
  function setActiveLink(sectionId) {
    links.forEach(link => {
      link.classList.toggle('active', link.getAttribute('data-section') === sectionId);
    });
  }

  // Load the active section from localStorage
  const activeSection = localStorage.getItem('activeDashboardSection') || 'dashboard';
  showSection(activeSection);
  setActiveLink(activeSection);

  // Add click event listeners to sidebar links
  links.forEach(link => {
    link.addEventListener('click', function (e) {
      e.preventDefault();
      const sectionId = this.getAttribute('data-section');
      showSection(sectionId);
      setActiveLink(sectionId);

      // If the Reservations section is active, load the correct view (form or table)
      if (sectionId === 'reservations') {
        const currentView = localStorage.getItem('reservationsCurrentView') || 'form';
        if (currentView === 'table') {
          showReservationsTable();
        } else {
          showReservationForm();
        }
      }
    });
  });

  // Clear localStorage on logout
  const logoutLink = document.getElementById('logout-link');
  if (logoutLink) {
    logoutLink.addEventListener('click', function () {
      localStorage.removeItem('activeDashboardSection');
      localStorage.removeItem('reservationsCurrentView');
    });
  }

  // Reservation View Toggling Logic
  function showReservationsTable() {
    document.getElementById('reservations').style.display = 'none';
    document.getElementById('reservationsTable').style.display = 'block';
    localStorage.setItem('reservationsCurrentView', 'table'); // Save the current view
  }

  function showReservationForm() {
    document.getElementById('reservations').style.display = 'block';
    document.getElementById('reservationsTable').style.display = 'none';
    localStorage.setItem('reservationsCurrentView', 'form'); // Save the current view
  }

  // Event listener for the "View Reservations" button
  const viewReservationsBtn = document.getElementById('viewReservationsBtn');
  if (viewReservationsBtn) {
    viewReservationsBtn.addEventListener('click', function () {
      showReservationsTable();
    });
  }

  // Event listener for the "Back to Reservations" button
  const backToReservationsBtn = document.getElementById('backToReservationsBtn');
  if (backToReservationsBtn) {
    backToReservationsBtn.addEventListener('click', function () {
      showReservationForm();
    });
  }

  // On page load, if the Reservations section is active, load the correct view
  if (activeSection === 'reservations') {
    const currentView = localStorage.getItem('reservationsCurrentView') || 'form';
    if (currentView === 'table') {
      showReservationsTable();
    } else {
      showReservationForm();
    }
  }

  // Profile Picture Upload Handling
  const profilePictureUpload = document.getElementById('profile-picture-upload');
  if (profilePictureUpload) {
    profilePictureUpload.addEventListener('change', function (event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function (e) {
          document.getElementById('profile-picture').src = e.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
  }


  // Fetch labs for dropdown
  fetchLabs();

  // Fetch session history for the logged-in student
  const studentIdno = "{{ session.student_idno }}"; // Get student ID from session
  if (studentIdno) {
    fetchSessionHistory(studentIdno);
  }
});

function saveProfileChanges() {
  const updatedData = {
    firstname: document.getElementById('editable-firstname').value,
    lastname: document.getElementById('editable-lastname').value,
    midname: document.getElementById('editable-midname').value, // Ensure this line is present
    course: document.getElementById('editable-course').value,
    year_level: document.getElementById('editable-year-level').value,
    email: document.getElementById('editable-email').value,
    username: document.getElementById('editable-username').value
  };

  const formData = new FormData();
  formData.append('data', JSON.stringify(updatedData));
  const profilePictureFile = document.getElementById('profile-picture-upload').files[0];
  if (profilePictureFile) {
    formData.append('profile_picture', profilePictureFile);
  }

  fetch('/update_profile', {
    method: 'POST',
    body: formData
  })
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      if (data.success) {
        alert('Profile updated successfully!');
        window.location.reload(); // Refresh the page to reflect changes
      } else {
        alert('Failed to update profile: ' + data.message);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert('An error occurred while updating the profile.');
    });
}






function fetchLabs() {
  fetch('/get_labs')
    .then(response => response.json())
    .then(data => {
      const labSelect = document.getElementById('lab_name');
      if (labSelect) {
        labSelect.innerHTML = '<option value="">Select Lab</option>'; // Reset options

        if (data.success && data.labs.length > 0) {
          data.labs.forEach(lab => {
            const option = document.createElement('option');
            option.value = lab.id;  // Use the lab ID as the value
            option.textContent = lab.lab_name;  // Use the lab name as the display text
            labSelect.appendChild(option);
          });
        } else {
          console.error('No labs found or error in response');
        }
      }
    })
    .catch(error => console.error('Error fetching labs:', error));
}

function formatDuration(seconds) {
  if (!seconds) return 'N/A';

  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;

  let durationString = '';
  if (hours > 0) durationString += `${hours}h `;
  if (minutes > 0) durationString += `${minutes}m `;
  if (secs > 0 || durationString === '') durationString += `${secs}s`;

  return durationString.trim();
}

let currentPage = 1;
let rowsPerPage = 5;
let sessionData = [];

function fetchSessionHistory(studentIdno) {
  fetch(`/get_session_history/${studentIdno}`)
    .then(response => response.json())
    .then(data => {
      sessionData = data;
      renderTable();
      renderChart();
    })
    .catch(error => console.error('Error fetching session history:', error));
}

function renderTable() {
  const sessionHistoryBody = document.getElementById('session-history-body');
  const prevButton = document.getElementById('prev-page');
  const nextButton = document.getElementById('next-page');
  const pageInfo = document.getElementById('page-info');

  if (sessionHistoryBody) {
    sessionHistoryBody.innerHTML = ''; // Clear existing rows

    const start = (currentPage - 1) * rowsPerPage;
    const end = start + rowsPerPage;
    const paginatedData = sessionData.slice(start, end);

    paginatedData.forEach((session, index) => {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>Session ${start + index + 1}</td>
        <td>${session.login_time}</td>
        <td>${session.logout_time || 'Active'}</td>
        <td>${formatDuration(session.duration)}</td>
      `;
      sessionHistoryBody.appendChild(row);
    });

    // Update pagination controls
    prevButton.disabled = currentPage === 1;
    nextButton.disabled = end >= sessionData.length;
    pageInfo.textContent = `Page ${currentPage} of ${Math.ceil(sessionData.length / rowsPerPage)}`;
  }
}

function renderChart() {
  const loginTimes = [];
  const durationsInSeconds = [];

  sessionData.forEach(session => {
    if (session.logout_time) {
      loginTimes.push(session.login_time);
      durationsInSeconds.push(session.duration);
    }
  });

  const ctx = document.getElementById('sessionChart')?.getContext('2d');
  if (ctx) {
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: loginTimes,
        datasets: [{
          label: 'Session Duration',
          data: durationsInSeconds,
          backgroundColor: 'hsla(273, 77%, 65%, 0.2)',
          borderColor: 'hsl(273, 77%, 65%)',
          borderWidth: 2,
          fill: true,
          tension: 0.4,
          pointRadius: 3,
          pointBackgroundColor: 'hsl(273, 77%, 65%)',
          pointBorderColor: 'hsl(273, 77%, 65%)',
          pointHoverRadius: 5,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'nearest',
          intersect: false,
        },
        scales: {
          y: {
            beginAtZero: true,
            grid: {
              display: false,
            },
            title: {
              display: window.innerWidth > 768,
              text: 'Duration (seconds)'
            },
            ticks: {
              color: 'hsl(273, 77%, 65%)',
            }
          },
          x: {
            grid: {
              display: false,
            },
            title: {
              display: window.innerWidth > 768,
              text: 'Login Time'
            },
            ticks: {
              display: window.innerWidth > 768,
              color: 'hsl(273, 77%, 65%)',
            }
          }
        },
        plugins: {
          legend: {
            display: window.innerWidth > 768,
            position: 'top',
            labels: {
              color: 'hsl(273, 77%, 65%)',
            }
          },
          tooltip: {
            enabled: true,
            mode: 'nearest',
            intersect: false,
            backgroundColor: 'hsl(273, 77%, 65%)',
            titleColor: '#fff',
            bodyColor: '#fff',
            callbacks: {
              label: function (context) {
                const durationInSeconds = context.raw;
                const hours = Math.floor(durationInSeconds / 3600);
                const minutes = Math.floor((durationInSeconds % 3600) / 60);
                const seconds = durationInSeconds % 60;
                return `Duration: ${hours}h ${minutes}m ${seconds}s`;
              }
            }
          }
        }
      }
    });
  }
}

// Pagination event listeners
document.getElementById('prev-page').addEventListener('click', () => {
  if (currentPage > 1) {
    currentPage--;
    renderTable();
  }
});

document.getElementById('next-page').addEventListener('click', () => {
  if (currentPage < Math.ceil(sessionData.length / rowsPerPage)) {
    currentPage++;
    renderTable();
  }
});

// Utility function to format duration
function formatDuration(durationInSeconds) {
  const hours = Math.floor(durationInSeconds / 3600);
  const minutes = Math.floor((durationInSeconds % 3600) / 60);
  const seconds = durationInSeconds % 60;
  return `${hours}h ${minutes}m ${seconds}s`;
}

let inactivityTime = function () {
  const INACTIVITY_LIMIT = 15 * 60 * 1000; // 15 minutes in milliseconds
  let timeout;

  // Function to log out the user
  function logout() {
    fetch('/logout', { method: 'POST' })
      .then(response => {
        if (response.redirected) {
          window.location.href = response.url;
        }
      });
  }

  // Function to reset the inactivity timer
  function resetTimer() {
    clearTimeout(timeout);
    timeout = setTimeout(logout, INACTIVITY_LIMIT); // Set new timeout
  }

  // Start the timer when the page loads
  resetTimer();

  // Event listeners to reset the timer on user activity
  document.onmousemove = resetTimer;
  document.onkeypress = resetTimer;
  document.onscroll = resetTimer;
};

// Start tracking inactivity
inactivityTime();

function checkSidebarHeight() {
  const sidebar = document.querySelector('.sidebar');
  const sidebarContentHeight = sidebar.scrollHeight; // Get the total height of the sidebar content

  // If sidebar content height exceeds 662px, apply max-height
  if (sidebarContentHeight > 662) {
    sidebar.classList.add('max-height');
  } else {
    sidebar.classList.remove('max-height');
  }
}

// Run the function on page load and window resize
window.addEventListener('load', checkSidebarHeight);
window.addEventListener('resize', checkSidebarHeight);


// Weekly Lab Usage Chart (Line Chart)
const weeklyUsageCtx = document.getElementById('weeklyUsageChart').getContext('2d');

// Create a gradient for the chart background below the line
const gradient = weeklyUsageCtx.createLinearGradient(0, 0, 0, 400);
gradient.addColorStop(0, 'rgba(207, 159, 255, 0.3)'); // Light purple (matches line color)
gradient.addColorStop(1, 'rgba(207, 159, 255, 0)'); // Transparent

// Initialize the chart with empty data
const weeklyUsageChart = new Chart(weeklyUsageCtx, {
  type: 'line',
  data: {
    labels: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // Include Sunday
    datasets: [{
      label: 'Sessions Count',
      data: [0, 0, 0, 0, 0, 0, 0], // Start with 0s (7 days)
      borderColor: 'hsl(273, 77%, 65%)', // Purple line color
      borderWidth: 3, // Slightly thicker line
      fill: true, // Fill the area under the line
      backgroundColor: gradient, // Use the gradient as the fill background
      tension: 0.4, // Smooth the line
      pointRadius: 5, // Make data points larger
      pointBackgroundColor: 'hsl(273, 77%, 65%)', // Purple point color
      pointBorderColor: '#fff', // White border for points
      pointHoverRadius: 7, // Increase size on hover
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false, // Allow the chart to resize freely
    scales: {
      y: {
        beginAtZero: true,
        grid: {
          color: 'rgba(200, 200, 200, 0.1)', // Light grid lines
          lineWidth: 1,
        },
        ticks: {
          color: 'hsl(273, 77%, 65%)', // Purple tick labels
        },
      },
      x: {
        display: window.innerWidth > 600, // Hide x-axis labels on small screens
        grid: {
          display: false, // Hide vertical grid lines
        },
        ticks: {
          color: 'hsl(273, 77%, 65%)', // Purple tick labels
        },
      },
    },
    plugins: {
      legend: {
        display: window.innerWidth > 600, // Hide legend on small screens
        position: 'top',
        labels: {
          color: 'hsl(273, 77%, 65%)', // Purple legend text
        },
      },
      tooltip: {
        enabled: true,
        backgroundColor: 'hsl(273, 77%, 65%)', // Purple tooltip background
        titleColor: '#fff', // White tooltip title
        bodyColor: '#fff', // White tooltip body
      },
    },
  },
});

// Pass the student ID from Flask to JavaScript
const studentId = "{{ student.idno }}"; // Replace with your actual variable
updateChart(studentId); // Call the function with the student ID

function updateChart(studentId) {
  fetch(`/get_weekly_usage/${studentId}`)
    .then(response => response.json())
    .then(data => {
      console.log("Fetched Data:", data);  // Debugging: Print the fetched data

      const labels = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; // Include Sunday
      const usageData = labels.map(day => data[day] || 0); // If no record, set to 0

      console.log("Mapped Data:", usageData);  // Debugging: Print the mapped data

      // Update the chart data
      weeklyUsageChart.data.labels = labels;
      weeklyUsageChart.data.datasets[0].data = usageData;
      weeklyUsageChart.update();
    })
    .catch(error => console.error('Error fetching session data:', error));
}

// Handle window resize to dynamically show/hide labels and legend
window.addEventListener('resize', () => {
  weeklyUsageChart.options.scales.x.display = window.innerWidth > 600;
  weeklyUsageChart.options.plugins.legend.display = window.innerWidth > 600;
  weeklyUsageChart.update();
});


const progressBars = document.querySelectorAll('.circular-progress');

progressBars.forEach(progressBar => {
    const progress = parseFloat(progressBar.getAttribute('data-progress'));
    const max = parseFloat(progressBar.getAttribute('data-max'));
    const percentage = (progress / max) * 100; // Calculate the percentage
    const progressValue = (progress / max) * 283; // Calculate the stroke-dashoffset

    const progressCircle = progressBar.querySelector('.progress-bar');
    progressCircle.style.strokeDashoffset = 283 - progressValue; // Update the progress bar

    // Set the progress bar color based on the percentage
    if (percentage >= 75) {
        progressCircle.style.stroke = '#4CAF50'; // Green
    } else if (percentage >= 50) {
        progressCircle.style.stroke = '#FFC107'; // Yellow
    } else if (percentage >= 25) {
        progressCircle.style.stroke = '#FF5722'; // Dark Orange (closer to red)
    } else {
        progressCircle.style.stroke = '#F44336'; // Red
    }
});

document.addEventListener('DOMContentLoaded', function () {
  const reservationDateInput = document.getElementById('reservation_date');


  // Set the reservation date to today's date and disable editing
  const today = new Date().toISOString().split('T')[0];
  reservationDateInput.value = today;
  reservationDateInput.readOnly = true;

});

document.getElementById('reservationForm').addEventListener('submit', async function (e) {
  e.preventDefault();

  const formData = new FormData(this);

  try {
    const response = await fetch('/reservations', {
      method: 'POST',
      body: formData,
    });

    const result = await response.json();

    if (result.status === 'success') {
      Swal.fire({
        title: 'Success!',
        text: result.message,
        icon: 'success',
        confirmButtonColor: '#3085d6',
        customClass: {
          popup: 'swal-default-size',
        },
      }).then(() => {
        location.reload(); // Refresh the page
      });
    } else {
      Swal.fire({
        title: 'Error!',
        text: result.message,
        icon: 'error',
        confirmButtonColor: '#d33',
        customClass: {
          popup: 'swal-default-size',
        },
      });
    }
  } catch (error) {
    Swal.fire({
      title: 'Error!',
      text: 'An error occurred while submitting the form.',
      icon: 'error',
      confirmButtonColor: '#d33',
      customClass: {
        popup: 'swal-default-size',
      },
    });
  }
});

  // Prevent form submission if there are validation errors
  document.getElementById('reservationForm').addEventListener('submit', function (event) {
    if (!this.checkValidity()) {
      event.preventDefault();
    }
  });






   // JavaScript to handle the SPA behavior
   document.getElementById('viewReservationsBtn').addEventListener('click', function() {
    // Hide the reservation form
    document.getElementById('reservations').style.display = 'none';
    // Show the reservations table
    document.getElementById('reservationsTable').style.display = 'block';
    // Optionally, load reservations data here via AJAX
  });





const approveButtons = document.querySelectorAll('.approve-btn');
const editButtons = document.querySelectorAll('.edit-btn');
const cancelButtons = document.querySelectorAll('.cancel-btn');


cancelButtons.forEach((button) => {
    button.addEventListener('click', function () {
        const row = this.closest('tr');
        const reservationId = row.dataset.reservationId;

        // SweetAlert confirmation with default scaling
        Swal.fire({
            title: "Are you sure?",
            text: "You are about to cancel this reservation!",
            icon: "warning",
            showCancelButton: true,
            confirmButtonColor: "#d33",
            cancelButtonColor: "#3085d6",
            confirmButtonText: "Yes, cancel it!",
            cancelButtonText: "No, keep it",
            customClass: {
                popup: 'swal-default-size' // Apply custom class to override scaling
            }
        }).then((result) => {
            if (result.isConfirmed) {
                // Update status to "Cancelled"
                const statusCell = row.querySelector('td:nth-child(7)');
                statusCell.textContent = 'Cancelled';

                // Disable all buttons in the action cell
                const actionCell = row.querySelector('td:nth-child(8)');
                actionCell.querySelectorAll('button').forEach((btn) => {
                    btn.disabled = true;
                });

                // Send an AJAX request to cancel the reservation
                fetch(`/cancel-reservation/${reservationId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                })
                .then((response) => response.json())
                .then((data) => {
                    if (data.success) {
                        Swal.fire({
                            title: "Cancelled!",
                            text: "Your reservation has been cancelled.",
                            icon: "success",
                            confirmButtonColor: "#3085d6",
                            customClass: {
                                popup: 'swal-default-size'
                            }
                        }).then(() => {
                            // Reload to reflect changes
                            window.location.reload();
                        });
                    } else {
                        Swal.fire("Error!", "Failed to cancel the reservation.", "error");
                    }
                })
                .catch((error) => {
                    console.error('Error:', error);
                    Swal.fire("Error!", "Something went wrong.", "error");
                });
            }
        });
    });
});


 // Listen for new reservation updates
 socket.on('new_reservation', function (data) {
        // If the reservation belongs to the current student, update the UI
        if (data.student_idno === session.student_idno) {
            const reservationsBody = document.getElementById('reservationsBody');
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${data.student_idno}</td>
                <td>${data.student_name}</td>
                <td>${data.lab_id}</td>
                <td>${data.purpose}</td>
                <td>${data.reservation_date}</td>
                <td>${data.logged_in}</td>
                <td>${data.logged_out}</td>
                <td>${data.status}</td>
            `;
            reservationsBody.appendChild(row);
        }
    });

    // Listen for reservation status updates
    socket.on('reservation_updated', function (data) {
        const { reservation_id, status } = data;

        // Find the reservation row and update its status
        const row = document.querySelector(`tr[data-reservation-id="${reservation_id}"]`);
        if (row) {
            const statusCell = row.querySelector('td:nth-child(8)');
            statusCell.textContent = status;
        }
    });

  document.addEventListener("DOMContentLoaded", function () {
    let tableBody = document.getElementById("reservationsBody");
    let rows = Array.from(tableBody.querySelectorAll("tr"));

    // Sort: Show Pending first, then Approved
    rows.sort((a, b) => {
        let statusA = a.getAttribute("data-status");
        let statusB = b.getAttribute("data-status");

        if (statusA === "pending" && statusB !== "pending") return -1;
        if (statusA !== "pending" && statusB === "pending") return 1;
        return 0;
    });

    // Re-append sorted rows to the table
    rows.forEach(row => tableBody.appendChild(row));

    // Set default filter to "Pending"
    let statusFilter = document.getElementById("statusFilter");
    statusFilter.value = "pending";

    // Apply filter on page load
    function applyFilter() {
        let filterValue = statusFilter.value;
        rows.forEach(row => {
            let status = row.getAttribute("data-status");
            row.style.display = (filterValue === "all" || status === filterValue) ? "" : "none";
        });
    }

    applyFilter(); // Show only Pending on load

    // Reapply filter when dropdown changes
    statusFilter.addEventListener("change", applyFilter);
});

const studentIdno = "{{ session.student_idno }}"; // This will be replaced by your server-side template engine

// Toggle chat modal and load chat history
function toggleChat() {
    const chatModal = document.getElementById("chatModal");
    chatModal.classList.toggle("active");

    if (chatModal.classList.contains("active")) {
        loadChatHistory(); // Load chat history when modal opens
    }
}

// Load chat history from the backend
async function loadChatHistory() {
    const chatMessages = document.getElementById("chatMessages");
    chatMessages.innerHTML = ""; // Clear existing messages

    try {
        const response = await fetch(`/chat/history?student_idno=${studentIdno}`);
        const history = await response.json();

        history.forEach((message) => {
            addMessage(message.sender, message.message);
        });
    } catch (error) {
        console.error("Failed to load chat history:", error);
    }
}
function handleKeyPress(event) {
    if (event.key === 'Enter') {
        sendMessage(); // Call sendMessage when Enter is pressed
    }
}
async function sendMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();

    if (message) {
        // Add user message to the chat window
        addMessage('user', message);
        input.value = '';

        // Send the message to the backend
        try {
            const response = await fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ message, student_idno: studentIdno })
            });

            const data = await response.json();

            // Check if the bot's response is the special delete success message
            if (data.reply === "__DELETE_SUCCESS__") {
                // Auto-refresh the page after a short delay (e.g., 1 second)
                setTimeout(() => {
                    location.reload();
                }, 1000); // 1000ms = 1 second
            } else {
                // Add bot's reply to the chat window
                addMessage('bot', data.reply);
            }
        } catch (error) {
            console.error("Failed to send message:", error);
        }
    }
}

function addMessage(sender, message) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', `${sender}-message`);

    // Add sender name and student ID (if user)
    const senderName = sender === 'bot' ? 
        `<span class="bot-name">CCS BOT</span>` : 
        `User (ID: ${studentIdno})`;

    const messageContent = document.createElement('div');
    messageContent.classList.add('message-content');

    // Check if the message contains a code block
    if (message.includes('```')) {
        // Extract the code block
        const codeBlock = message.match(/```([\s\S]*?)```/)[1];
        const formattedCode = `<pre><code>${codeBlock}</code></pre>`;

        // Replace the code block in the message with the formatted code
        message = message.replace(/```[\s\S]*?```/, formattedCode);
    }

    // Insert the message content with proper formatting
    messageContent.innerHTML = `<strong>${senderName}:</strong> ${message}`;

    // Append the message content to the message div
    messageDiv.appendChild(messageContent);

    // If sender is bot, apply the 'bot-message' class to style it
    if (sender === 'bot') {
        messageDiv.classList.add('bot-message');
    }

    // Append the message to the chat window
    chatMessages.appendChild(messageDiv);

    // Auto-scroll to the latest message
    chatMessages.scrollTop = chatMessages.scrollHeight;
}



    socket.on('connect', function () {
        console.log('WebSocket connected to', socketURL);
    });

    socket.on('disconnect', function () {
        console.log('WebSocket disconnected');
    });

    socket.on('connect_error', function (error) {
        console.error('WebSocket connection error:', error);
    });

  // Function to fetch announcements
function fetchAnnouncements() {
    fetch('/get_announcements')
        .then(response => response.json())
        .then(data => {
            const announcementsList = document.getElementById('announcements-list');
            if (announcementsList) {
                announcementsList.innerHTML = ''; // Clear existing announcements

                data.forEach(announcement => {
                    const announcementDate = new Date(announcement.announcement_date).toLocaleString();

                    const announcementBox = document.createElement('div');
                    announcementBox.className = 'announcement-box';

                    announcementBox.innerHTML = `
                        <div class="announcement-header">
                            <span class="announcement-date">${announcementDate}</span>
                            <span class="announcement-admin">Posted by: ${announcement.admin_username}</span>
                        </div>
                        <div class="announcement-content">
                            <p>${announcement.announcement_text}</p>
                        </div>
                    `;

                    announcementsList.appendChild(announcementBox);
                });
            }
        })
        .catch(error => console.error('Error fetching announcements:', error));
}


// Fetch announcements when the page loads
fetchAnnouncements();
    socket.on('announcement_updated', (data) => {
    console.log('Updated announcement:', data);
    fetchAnnouncements(); // Refresh the announcements list
    });

    // Listen for deleted announcements
    socket.on('announcement_deleted', (data) => {
        console.log('Deleted announcement:', data);
        fetchAnnouncements(); // Refresh the announcements list
    });


    // Listen for new announcements
    socket.on('new_announcement', (data) => {
        console.log('New announcement:', data);
        // Add the new announcement to the list
        const announcementsList = document.getElementById('announcements-list');
        if (announcementsList) {
            const announcementDate = new Date(data.announcement_date).toLocaleString();

            const announcementBox = document.createElement('div');
            announcementBox.className = 'announcement-box';

            announcementBox.innerHTML = `
                <div class="announcement-header">
                    <span class="announcement-date">${announcementDate}</span>
                    <span class="announcement-admin">Posted by: ${data.admin_username}</span>
                </div>
                <div class="announcement-content">
                    <p>${data.announcement_text}</p>
                </div>
            `;

            announcementsList.prepend(announcementBox); // Add to the top of the list
        }
    });

  // Star Rating Interaction
const stars = document.querySelectorAll('.star-rating .star');
stars.forEach(star => {
  star.addEventListener('click', function () {
    const value = this.getAttribute('data-value');
    stars.forEach(s => {
      s.classList.toggle('active', s.getAttribute('data-value') <= value); // This will highlight all stars up to the clicked one
    });
  });
});

document.getElementById('feedbackForm').addEventListener('submit', function (event) {
    event.preventDefault();

    const lab = document.getElementById('labSelection').value;
    const feedbackText = document.getElementById('feedbackText').value;

    // Get the highest rating by checking all active stars
    const rating = Array.from(document.querySelectorAll('.star-rating .star.active'))
                        .map(star => star.getAttribute('data-value'))
                        .reduce((max, current) => Math.max(max, current), 0) || 0; // Get the highest value or 0 if no star is selected

    // Retrieve student_idno from the session or a hidden input field
    const student_idno = document.getElementById('student_idno').value;

    // Send feedback data to the server using socket
    socket.emit('submit_feedback', {
        lab: lab,
        feedback_text: feedbackText,
        rating: rating,
        student_idno: student_idno
    });

    // Reset the form after submission
    document.getElementById('feedbackForm').reset();
    document.querySelectorAll('.star-rating .star').forEach(star => star.classList.remove('active'));

    // Display SweetAlert for feedback submission with custom size
    Swal.fire({
        icon: 'success',
        title: 'Feedback Submitted!',
        text: 'Thank you for your feedback.',
        customClass: {
            popup: 'swal-default-size'
        }
    });
});

socket.on('new_announcement', (data) => {
    const notificationDropdown = document.getElementById('notificationDropdown');
    const notificationItem = document.createElement('div');
    notificationItem.classList.add('notification-item');
    if (!data.is_read) notificationItem.classList.add('unread');

    notificationItem.innerHTML = `
        <div class="notification-icon">
            <i class="fas fa-bell"></i>
        </div>
        <div class="notification-content">
            <div class="notification-title">New Announcement</div>
            <div class="notification-text">${data.announcement_text}</div>
            <div class="notification-time">Just now</div>
        </div>
    `;

    // Add click event to mark as read
    notificationItem.addEventListener('click', () => {
        markNotificationAsRead(data.id);
    });

    notificationDropdown.insertBefore(notificationItem, notificationDropdown.firstChild);
    updateNotificationCount();
});


// Mark all as read
function markNotificationAsRead(notificationId) {
    fetch('/mark_notification_as_read', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ notification_id: notificationId }),
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Remove the 'unread' class from the notification item
            const notificationItem = document.querySelector(`.notification-item[data-id="${notificationId}"]`);
            if (notificationItem) {
                notificationItem.classList.remove('unread');
                updateNotificationCount();
            }
        }
    })
    .catch(error => console.error('Error marking notification as read:', error));
}
 
document.addEventListener('DOMContentLoaded', () => {
    fetch('/get_unread_notifications')
        .then(response => response.json())
        .then(data => {
            if (data.success && Array.isArray(data.data)) {
                const notificationDropdown = document.getElementById('notificationDropdown');
                notificationDropdown.innerHTML = ''; // Clear existing notifications

                data.data.forEach(notification => {
                    const notificationItem = document.createElement('div');
                    notificationItem.classList.add('notification-item');
                    if (!notification.is_read) notificationItem.classList.add('unread');

                    notificationItem.innerHTML = `
                        <div class="notification-icon">
                            <i class="fas fa-bell"></i>
                        </div>
                        <div class="notification-content">
                            <div class="notification-title">New Announcement</div>
                            <div class="notification-text">${notification.announcement_text}</div>
                            <div class="notification-time">${notification.announcement_date}</div>
                        </div>
                    `;

                    // Add click event to mark as read
                    notificationItem.addEventListener('click', () => {
                        markNotificationAsRead(notification.id);
                    });

                    notificationDropdown.appendChild(notificationItem);
                });

                updateNotificationCount(); // Update the notification badge count
            } else {
                console.error('Invalid response format:', data);
            }
        })
        .catch(error => console.error('Error fetching unread notifications:', error));
});

function updateNotificationCount() {
    const unreadCount = document.querySelectorAll('.notification-item.unread').length;
    const notificationBadge = document.getElementById('notificationBadge');
    if (unreadCount > 0) {
        notificationBadge.textContent = unreadCount;
        notificationBadge.style.display = 'flex';
    } else {
        notificationBadge.style.display = 'none';
    }
}

const notificationBtn = document.getElementById('notificationBtn');
    const notificationDropdown = document.getElementById('notificationDropdown');
    const markAllReadBtn = document.getElementById('markAllRead');
    const unreadItems = document.querySelectorAll('.unread');
    const notificationBadge = document.getElementById('notificationBadge');
    
    // Count unread notifications
    function updateNotificationCount() {
      const unreadCount = document.querySelectorAll('.unread').length;
      if (unreadCount > 0) {
        notificationBadge.textContent = unreadCount;
        notificationBadge.style.display = 'flex';
      } else {
        notificationBadge.style.display = 'none';
      }
    }
    
    // Initialize notification count
    updateNotificationCount();

    // Toggle dropdown
    notificationBtn.addEventListener('click', function() {
      notificationDropdown.classList.toggle('show');
    });

    // Close dropdown when clicking outside
    window.addEventListener('click', function(event) {
      if (!event.target.matches('.notification-button') && 
          !event.target.matches('.fa-bell') &&
          !notificationDropdown.contains(event.target)) {
        if (notificationDropdown.classList.contains('show')) {
          notificationDropdown.classList.remove('show');
        }
      }
    });

    // Mark all as read functionality
    markAllReadBtn.addEventListener('click', function() {
      const unreadItems = document.querySelectorAll('.unread');
      unreadItems.forEach(item => {
        item.classList.remove('unread');
      });
      updateNotificationCount();
    });


    document.addEventListener('DOMContentLoaded', function () {
  // Fetch and display reservation history
  fetchReservationHistory();

  // Event listener for the feedback modal close button
  document.querySelector('.close-modal').addEventListener('click', function () {
    closeFeedbackModal();
  });

  // Event listener for star ratings
  document.querySelectorAll('.star-rating .star').forEach(star => {
    star.addEventListener('click', function () {
      const rating = this.getAttribute('data-value');
      document.getElementById('rating').value = rating;
      highlightStars(rating);
    });
  });

  // Event listener for feedback form submission
  document.getElementById('feedbackForm').addEventListener('submit', function (e) {
    e.preventDefault();
    submitFeedback();
  });
});


// Function to fetch and display reservation history
function fetchReservationHistory() {
  console.log('Fetching reservation history...'); // Log when the fetching starts
  
  fetch('/get_reservation_history')
    .then(response => {
      console.log('Response received:', response); // Log the response object

      if (!response.ok) {
        throw new Error('Failed to fetch reservation history');
      }

      return response.json();
    })
    .then(data => {
      console.log('Data received:', data); // Log the data received from the server

      if (data.success) {
        const historyBody = document.getElementById('historyBody');
        historyBody.innerHTML = ''; // Clear existing rows

        data.data.forEach(reservation => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${reservation.lab_name}</td>
            <td>${reservation.purpose}</td>
            <td>${reservation.reservation_date}</td>
            <td>${reservation.status}</td>
            <td>${reservation.logout_time || 'N/A'}</td>
            <td>
              ${reservation.status === 'Logged Out' ? 
                `<button class="submit-feedback-btn" data-reservation-id="${reservation.id}">Submit Feedback</button>` :
                `<button class="submit-feedback-btn" disabled style="background-color: gray; cursor: not-allowed;">Submit Feedback</button>`
              }
            </td>
          `;
          historyBody.appendChild(row);
        });

        // Add event listeners to feedback buttons
        document.querySelectorAll('.submit-feedback-btn:not(:disabled)').forEach(button => {
          button.addEventListener('click', function () {
            const reservationId = this.getAttribute('data-reservation-id');
            openFeedbackModal(reservationId);
          });
        });

      } else {
        console.log('Failed to fetch data: ', data.message); // Log failure message
      }
    })
    .catch(error => {
      console.error('Error fetching reservation history:', error); // Log any errors encountered
    });
}

// Function to submit feedback
function submitFeedback() {
  const reservationId = document.getElementById('reservationId').value;
  const feedbackText = document.getElementById('feedbackText').value;
  const rating = document.getElementById('rating').value;

  console.log('Submitting feedback for reservation ID:', reservationId); // Log the reservation ID being submitted
  console.log('Feedback text:', feedbackText); // Log the feedback text
  console.log('Rating:', rating); // Log the rating

  fetch('/submit_feedback', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      reservation_id: reservationId,
      feedback_text: feedbackText,
      rating: rating,
    }),
  })
    .then(response => response.json())
    .then(data => {
      console.log('Feedback submission response:', data); // Log the response from the feedback submission

      if (data.success) {
        alert('Feedback submitted successfully!');
        closeFeedbackModal();
        fetchReservationHistory(); // Refresh the history table
      } else {
        alert('Failed to submit feedback: ' + data.message);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert('An error occurred while submitting feedback.');
    });
}

// Function to open the feedback modal
function openFeedbackModal(reservationId) {
  console.log('Opening feedback modal for reservation ID:', reservationId); // Log the reservation ID
  document.getElementById('reservationId').value = reservationId;
  document.getElementById('feedbackModal').style.display = 'block';
}

// Function to close the feedback modal
function closeFeedbackModal() {
  console.log('Closing feedback modal'); // Log when the modal is being closed
  document.getElementById('feedbackModal').style.display = 'none';
  document.getElementById('feedbackForm').reset();
  document.querySelectorAll('.star-rating .star').forEach(star => star.classList.remove('active'));
}


socket.on('update_session_count', function(data) {
    try {
        console.log('Received data:', data);  // Debug: Log the received data

        // Ensure you're checking the correct student ID
        if (data.student_idno === studentIdno) {  // Ensure this event is for the current student
            const sessionsLeftElement = document.getElementById('sessions-left');
            console.log('Sessions Left Element:', sessionsLeftElement);  // Debug: Check if the element exists

            if (sessionsLeftElement) {
                // Update the sessions left in the DOM
                sessionsLeftElement.textContent = data.sessions_left;
                console.log('Updated sessions left:', data.sessions_left);

                // Optionally update the progress bar (if needed)
                const progressValueElement = document.querySelector('.progress-value');
                if (progressValueElement) {
                    progressValueElement.textContent = data.sessions_left;
                }
            } else {
                console.error("Element with id 'sessions-left' not found in the DOM.");
            }
        } else {
            console.error(`Received event for student ID ${data.student_idno}, but the current student ID is ${studentIdno}`);
        }
    } catch (error) {
        console.error("Error handling 'update_session_count' event:", error);
    }
});

// Optionally, handle page load event to ensure everything is ready before using socket
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM fully loaded and parsed");
    // You can initialize your socket listeners here as well, just in case you have any dynamic rendering.
});


// Example: Emit event when a student submits a reservation
document.getElementById('reservationForm').addEventListener('submit', function (e) {
    e.preventDefault();

    const formData = new FormData(this);

    fetch('/reservations', {
        method: 'POST',
        body: formData,
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Emit event to notify the admin
            socket.emit('new_reservation', {
                reservation_id: data.reservation_id,
                student_idno: data.student_idno,
                lab_name: data.lab_name,
                purpose: data.purpose,
                reservation_date: data.reservation_date,
            });
        } 
    })
    .catch(error => {
        console.error('Error submitting reservation:', error);
    });
});

// Example: Emit event when a student submits feedback
document.getElementById('feedbackForm').addEventListener('submit', function (e) {
    e.preventDefault();

    const formData = new FormData(this);

    fetch('/submit_feedback', {
        method: 'POST',
        body: formData,
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Emit event to notify the admin
            socket.emit('feedback_submitted', {
                reservation_id: data.reservation_id,
                feedback_text: data.feedback_text,
                rating: data.rating,
            });
        } else {
            alert('Failed to submit feedback: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error submitting feedback:', error);
    });
});


// Listen for reservation approval updates
socket.on('reservation_approved', (data) => {
    console.log('Reservation approved:', data);
    // Update the student's reservation status in the UI
    const reservationRow = document.querySelector(`tr[data-reservation-id="${data.reservation_id}"]`);
    if (reservationRow) {
        reservationRow.querySelector('.status').textContent = data.status;
    }
});

// Listen for logout updates
socket.on('reservation_updated', (data) => {
    console.log('Reservation updated:', data);
    // Update the student's reservation logout time in the UI
    const reservationRow = document.querySelector(`tr[data-reservation-id="${data.reservation_id}"]`);
    if (reservationRow) {
        reservationRow.querySelector('.logout-time').textContent = data.logout_time || 'N/A';
    }
});


   <div id="history" class="dashboard-section" style="display: none;">
          <h1>History</h1>
          <!-- History Table -->
          <table class="history-table">
            <thead>
              <tr>
                <th>Lab Name</th>
                <th>Purpose</th>
                <th>Reservation Date</th>
                <th>Status</th>
                <th>Logout Time</th>
                <th>Feedback</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <!-- Reservation history rows will be dynamically populated here -->
            </tbody>
          </table>
        </div>





my admin side

document.addEventListener('DOMContentLoaded', function () {
    // Fetch and display current sit-in reservations when the page loads
    fetchAndDisplayCurrentSitIn();

    // Handle logout button clicks using event delegation
    document.addEventListener('click', function (event) {
        if (event.target.classList.contains('logout-btn')) {
            const reservationId = event.target.getAttribute('data-reservation-id');
            handleLogout(reservationId);
        }
    });

    // Socket event listener for reservation updates (logout only)
    socket.on('reservation_updated', function (data) {
        const reservationId = data.reservation_id;
        const logoutTime = data.logout_time;

        // Update the reservation logout time in the UI
        const reservationRow = document.querySelector(`tr[data-reservation-id="${reservationId}"]`);
        if (reservationRow) {
            reservationRow.querySelector('.logout-time').textContent = logoutTime || 'N/A';

            // Hide the row if logout_time is set
            if (logoutTime) {
                reservationRow.style.display = 'none';
            }
        }
    });

    // Socket event listener for reservation approvals
    socket.on('reservation_approved', function (data) {
        const reservationId = data.reservation_id;
        const status = data.status;

        // Update the reservation status in the UI
        const reservationRow = document.querySelector(`tr[data-reservation-id="${reservationId}"]`);
        if (reservationRow) {
            reservationRow.querySelector('.status').textContent = status;
        }
    });
});

// Function to handle logout
function handleLogout(reservationId) {
    fetch(`/logout-student/${reservationId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
    })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Student logged out successfully');
                // Hide the row instead of deleting it
                const row = document.querySelector(`tr[data-reservation-id="${reservationId}"]`);
                if (row) {
                    row.style.display = 'none'; // Hide the row
                }
            } else {
                alert('Failed to log out student: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error during logout:', error);
        });
}

// Function to fetch and display current sit-in reservations
function fetchAndDisplayCurrentSitIn() {
    fetch('/get_currentsitin')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const tableBody = document.querySelector('#reservations-table tbody');
                tableBody.innerHTML = ''; // Clear existing rows

                data.data.forEach(reservation => {
                    const row = document.createElement('tr');
                    row.setAttribute('data-reservation-id', reservation.id);

                    row.innerHTML = `
                        <td>${reservation.student_idno}</td>
                        <td>${reservation.student_name}</td>
                        <td>${reservation.lab_name}</td>
                        <td>${reservation.purpose}</td>
                        <td>${reservation.reservation_date}</td>
                        <td>${reservation.login_time}</td>
                        <td class="logout-time">${reservation.logout_time || 'N/A'}</td>
                        <td class="status">${reservation.status}</td>
                        <td class="sessions-left">${reservation.sessions_left}</td>
                        <td>
                            <button class="logout-btn" data-reservation-id="${reservation.id}">Logout</button>
                        </td>
                    `;

                    tableBody.appendChild(row);
                });
            } else {
                console.error('Failed to fetch current sit-in reservations:', data.message);
            }
        })
        .catch(error => {
            console.error('Error fetching current sit-in reservations:', error);
        });
}


   <!-- Other Pages -->
            <div id="sit-in" class="page-content" style="display: none;">
                <h2>Current Sit In</h2>
                <div class="table-container">
                <table class="sit-in-table" id="reservations-table">
                    <thead>
                        <tr>
                            <th>Student ID</th>
                            <th>Student Name</th>
                            <th>Lab Name</th>
                            <th>Purpose</th>
                            <th>Reservation Date</th>
                            <th>Login Time</th>
                            <th>Logout Time</th>
                            <th>Status</th>
                            <th>Sessions Left</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Rows will be populated dynamically -->
                    </tbody>
                </table>
                </div>
            </div>


@app.route('/reservations', methods=['POST'])
def reservations():
    student_idno = session.get('student_idno')
    student_firstname = session.get('student_firstname', '')
    student_lastname = session.get('student_lastname', '')
    student_midname = session.get('student_midname', '')

    student_name = f"{student_firstname} {student_midname} {student_lastname}".strip()

    lab_id = request.form.get('lab_id', '').strip()
    purpose = request.form.get('purpose_select', '').strip()
    reservation_date = request.form.get('reservation_date', '').strip()
    sessions_left = int(request.form.get('sessions_left', 0))  # Get sessions_left from the form
    login_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')  # Current time as logged-in time

    # Check if all required fields are provided
    if not all([student_idno, student_name, lab_id, purpose, reservation_date]):
        return jsonify({'status': 'error', 'message': 'All fields are required'}), 400

    # Validate the reservation date format
    try:
        datetime.strptime(reservation_date, '%Y-%m-%d')
    except ValueError:
        return jsonify({'status': 'error', 'message': 'Invalid date format (YYYY-MM-DD expected)'}), 400

    # Check if the student already has a pending reservation
    if has_pending_reservation(student_idno):
        return jsonify({'status': 'error', 'message': 'You already have a pending reservation'}), 400

    # Check if the student has sessions left
    if sessions_left <= 0:
        return jsonify({'status': 'error', 'message': 'You have no sessions left'}), 400

    # Create the reservation (without decreasing sessions here)
    if create_reservation(
        student_idno=student_idno,
        student_name=student_name,
        lab_id=lab_id,
        purpose=purpose,
        reservation_date=reservation_date,
        login_time=login_time,  # Logged-in time
        status='Pending'
    ):
        # Emit a Socket.IO event to notify both admin and student
        socketio.emit('new_reservation', {
            'student_idno': student_idno,
            'student_name': student_name,
            'lab_id': lab_id,
            'purpose': purpose,
            'reservation_date': reservation_date,
            'login_time': login_time,
            'status': 'Pending'
        })
        return jsonify({'status': 'success', 'message': 'Reservation created successfully'}), 200
    else:
        return jsonify({'status': 'error', 'message': 'Failed to create reservation'}), 500


    
    
@app.route('/sit-in-reservation/<int:reservation_id>', methods=['POST'])
def sit_in_reservation(reservation_id):
    try:
        print(f"Attempting to approve reservation with ID: {reservation_id}")  # Print reservation ID
        
        # Fetch the reservation details
        reservation = get_reservation_by_id(reservation_id)
        if not reservation:
            print(f"Reservation with ID {reservation_id} not found")
            return jsonify({'success': False, 'message': 'Reservation not found'})
        
        print(f"Fetched reservation: {reservation}")  # Print reservation details
        
        # Update the reservation status to "Approved"
        if update_reservation_status(reservation_id, 'Approved'):
            print(f"Successfully updated reservation {reservation_id} status to 'Approved'")  # Print success message
            # Emit a Socket.IO event to notify both admin and student
            socketio.emit('reservation_approved', {
                'reservation_id': reservation_id,
                'status': 'Approved'
            })
            return jsonify({'success': True, 'message': 'Reservation approved successfully'})
        else:
            print(f"Failed to update reservation {reservation_id} status to 'Approved'")
            return jsonify({'success': False, 'message': 'Failed to update reservation status'})
    
    except Exception as e:
        print(f"Error in sit-in reservation for {reservation_id}: {str(e)}")  # Print the exception message
        return jsonify({'success': False, 'message': str(e)})

@app.route('/close-reservation/<int:reservation_id>', methods=['POST'])
def close_reservation(reservation_id):
    try:
        print(f"Attempting to close reservation with ID: {reservation_id}")  # Print reservation ID
        
        # Fetch the reservation details
        reservation = get_reservation_by_id(reservation_id)
        if not reservation:
            print(f"Reservation with ID {reservation_id} not found")
            return jsonify({'success': False, 'message': 'Reservation not found'})
        
        print(f"Fetched reservation: {reservation}")  # Print reservation details
        
        # Check if 2 hours have passed since the reservation was made
        reservation_time = datetime.strptime(reservation['login_time'], '%Y-%m-%d %H:%M:%S')
        current_time = datetime.now()
        time_difference = current_time - reservation_time
        
        print(f"Time difference (in seconds): {time_difference.total_seconds()}")  # Print time difference
        
        if time_difference.total_seconds() >= 7200:  # 2 hours = 7200 seconds
            # Delete the reservation
            print(f"Deleting reservation {reservation_id} as more than 2 hours have passed")
            delete_reservation(reservation_id)
            return jsonify({'success': True, 'message': 'Reservation deleted successfully (2 hours passed)'})
        else:
            print(f"Updating reservation {reservation_id} status to 'Disapproved'")  # Print action before updating status
            # Update the reservation status to "Disapproved"
            if update_reservation_status(reservation_id, 'Disapproved'):
                # Emit a Socket.IO event to notify both admin and student
                socketio.emit('reservation_updated', {
                    'reservation_id': reservation_id,
                    'status': 'Disapproved'
                })
                return jsonify({'success': True, 'message': 'Reservation disapproved successfully'})
            else:
                print(f"Failed to update reservation {reservation_id} status to 'Disapproved'")
                return jsonify({'success': False, 'message': 'Failed to update reservation status'})
    
    except Exception as e:
        print(f"Error in close reservation for {reservation_id}: {str(e)}")  # Print the exception message
        return jsonify({'success': False, 'message': str(e)})



@app.route('/logout-student/<int:reservation_id>', methods=['POST'])
def logout_student(reservation_id):
    try:
        print(f"Attempting to log out reservation with ID: {reservation_id}")  # Debug print

        # Fetch the reservation details
        reservation = get_reservation_by_id(reservation_id)
        if not reservation:
            print(f"Reservation with ID {reservation_id} not found")  # Debug print
            return jsonify({'success': False, 'message': 'Reservation not found'})

        # Record the logged-out time
        logout_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        print(f"Logout time recorded: {logout_time}")  # Debug print

        # Update the reservation with logged-out time (status remains unchanged)
        if update_reservation_logout(reservation_id, logout_time):
            print(f"Reservation {reservation_id} updated successfully")  # Debug print

            # Insert session history
            insert_session_history(
                student_idno=reservation['student_idno'],
                login_time=reservation['login_time'],
                logout_time=logout_time
            )

            # Deduct one session from the student's sessions_left
            student = get_student_by_idno(reservation['student_idno'])
            if student and student['sessions_left'] > 0:
                student['sessions_left'] -= 1
                update_student_sessions(student['idno'], student['sessions_left'])
                print(f"Updated sessions_left for student {student['idno']} to {student['sessions_left']}")  # Debug print

                # Emit a Socket.IO event to notify the student about the session update
                socketio.emit('update_session_count', {
                    'student_idno': student['idno'],
                    'sessions_left': student['sessions_left']
                }, room=student['idno'])  # Emit to the specific student's room

            # Emit a Socket.IO event to notify both admin and student
            socketio.emit('reservation_updated', {
                'reservation_id': reservation_id,
                'logout_time': logout_time,
                'sessions_left': student['sessions_left'] if student else 0
            })
            return jsonify({'success': True, 'message': 'Student logged out successfully'})
        else:
            print(f"Failed to update reservation {reservation_id}")  # Debug print
            return jsonify({'success': False, 'message': 'Failed to update reservation'})
    except Exception as e:
        print(f"Error in logout-student for {reservation_id}: {str(e)}")  # Debug print
        return jsonify({'success': False, 'message': str(e)})



def get_all_reservations(search_term='') -> list:
    if search_term:
        sql = """
        SELECT r.id, r.student_idno, r.student_name, l.lab_name, r.purpose, 
               r.reservation_date, r.login_time, r.logout_time, r.status
        FROM reservations r
        JOIN laboratories l ON r.lab_id = l.id
        WHERE r.student_idno LIKE ? AND r.status = 'Pending'
        """
        return getprocess(sql, (f"%{search_term}%",))
    else:
        sql = """
        SELECT r.id, r.student_idno, r.student_name, l.lab_name, r.purpose, 
               r.reservation_date, r.login_time, r.logout_time, r.status
        FROM reservations r
        JOIN laboratories l ON r.lab_id = l.id
        WHERE r.status = 'Pending'
        """
        return getprocess(sql)

@app.route('/get_reservation_history')
def get_reservation_history():
    if 'student_idno' not in session:
        print('Unauthorized access attempt. Student ID not in session.')
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    student_idno = session['student_idno']
    print(f"Fetching reservation history for student ID: {student_idno}")  # Log student ID fetching

    sql = """
    SELECT r.id, l.lab_name, r.purpose, r.reservation_date, r.status, r.logout_time
    FROM reservations r
    JOIN laboratories l ON r.lab_id = l.id
    WHERE r.student_idno = ? AND r.status IN ('Closed', 'Cancelled', 'Logged Out', 'Approved', 'Disapproved')
    ORDER BY r.reservation_date DESC
    """
    
    try:
        # Attempt to fetch reservations from the database
        reservations = getprocess(sql, (student_idno,))
        print(f"Found {len(reservations)} reservations for student ID: {student_idno}")  # Log number of reservations found

        return jsonify({"success": True, "data": reservations})  
    except Exception as e:
        # Catch any errors during the query process
        print(f"Error fetching reservation history: {e}")  # Log any errors during fetch
        return jsonify({"success": False, "message": "Error fetching reservation history"}), 500
    

@app.route('/get_reservations')
def get_reservations():
    if 'admin_username' not in session:
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    search_term = request.args.get('search', '').strip()
    reservations = get_all_reservations(search_term)  # Fetch reservations with lab_name
    reservation_list = []

    for reservation in reservations:
        # Fetch sessions_left for the student
        student_idno = reservation['student_idno']
        student = get_student_by_idno(student_idno)
        sessions_left = student['sessions_left'] if student else 0

        reservation_list.append({
            "id": reservation['id'],
            "student_idno": reservation['student_idno'],
            "student_name": reservation['student_name'],
            "lab_name": reservation['lab_name'],  # Use lab_name instead of lab_id
            "purpose": reservation['purpose'],
            "reservation_date": reservation['reservation_date'],
            "login_time": reservation['login_time'],  # Use login_time instead of time_in
            "logout_time": reservation['logout_time'],  # Use logout_time instead of time_out
            "status": reservation['status'],
            "sessions_left": sessions_left  # Add sessions_left to the response
        })

    return jsonify({"success": True, "data": reservation_list})

@app.route('/get_currentsitin')
def get_currentsitin():
    if 'admin_username' not in session:
        print("Unauthorized access attempt. Admin not logged in.")  # Debug print
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    try:
        # Fetch reservations that are approved and have a login_time but no logout_time
        sql = """
        SELECT r.id, r.student_idno, r.student_name, l.lab_name, r.purpose, 
               r.reservation_date, r.login_time, r.logout_time, r.status
        FROM reservations r
        JOIN laboratories l ON r.lab_id = l.id
        WHERE r.status = 'Approved' AND r.logout_time IS NULL
        """
        reservations = getprocess(sql)
        print(f"Fetched {len(reservations)} current sit-in reservations.")  # Debug print

        reservation_list = []
        for reservation in reservations:
            # Fetch sessions_left for the student
            student_idno = reservation['student_idno']
            student = get_student_by_idno(student_idno)
            sessions_left = student['sessions_left'] if student else 0

            reservation_list.append({
                "id": reservation['id'],
                "student_idno": reservation['student_idno'],
                "student_name": reservation['student_name'],
                "lab_name": reservation['lab_name'],
                "purpose": reservation['purpose'],
                "reservation_date": reservation['reservation_date'],
                "login_time": reservation['login_time'],
                "logout_time": reservation['logout_time'],
                "status": reservation['status'],
                "sessions_left": sessions_left
            })

        return jsonify({"success": True, "data": reservation_list})
    except Exception as e:
        print(f"Error fetching current sit-in reservations: {e}")  # Debug print
        return jsonify({"success": False, "message": "Error fetching current sit-in reservations"}), 500



@app.route('/student_dashboard')
def student_dashboard():
    pagetitle = "Student Dashboard"
    
    # Ensure the user is logged in
    if 'user_username' not in session:
        flash("You need to login first", 'warning')
        return redirect(url_for('login'))

    # Retrieve student data based on the username stored in the session
    student = get_student_by_username(session['user_username'])
    if not student:
        flash("Student not found", 'danger')
        return redirect(url_for('login'))

    # Fetch the lab names and current session information
    labs = get_lab_names()  
    current_session = get_total_session(student['idno'])

    # Get the student's reservations
    reservations = get_reservations_by_student_id(student['idno'])

    return render_template(
        'client/studentdashboard.html',
        student=student,
        pagetitle=pagetitle,
        labs=labs,
        idno=student['idno'],
        current_session=current_session,
        reservations=reservations 
    )
What i want is that when the logged out time is there in student the feedback will be clicked. and the table in history design in i provide you the css. and make sure the sessions. will be socket on and it will work on the student side. and all that i been inputed there should be on socket so that i won't refresh the page cause that's so annoying
